/* AUTO-GENERATED DO NOT EDIT */
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include "sdkconfig.h"
#include "esp_log.h"
#include "cbor.h"
#include "component_config.h"

#define SUPPORTED_VERSION 2
static const char TAG[] = "compcfg";

/* Enum Mappings */
struct choice {
	const char *str;
	int val;
};

enum field_flags {
    FIELD_FLAG_DEFAULT,
    FIELD_FLAG_OPTIONAL
};

struct field;

typedef int (*validateAndSet_t)(CborValue *, struct field *, void *);

struct field {
    char *key;
    enum field_flags flags;  
    size_t dataOffset;
    const struct choice *choices;
    validateAndSet_t validateAndSet;
};

struct component {
    char *name;
    size_t structSize;
    size_t arrayOffset;
    size_t arrayCountOffset;
    struct field *fields;
    size_t fieldsCount;
};

{% if "choice" in used_types %}
{% if type_conditions["choice"] %}
#if {{type_conditions["choice"]}}
{% endif %}
static int findChoice(const struct choice *choices, char *input, int *output) 
{
    int i;
    for (i = 0; choices[i].str != NULL; i++){
        if (strcmp(choices[i].str, input) == 0) {
            *output = choices[i].val;
            return 0;
        }
    }
    return -1;
}
static int validateAndSetChoice(CborValue *value, struct field *field, void *output)
{
    char *text = NULL;
    size_t textLen = 0;
    if (!cbor_value_is_text_string(value)) {
        return -1;
    }
    if (cbor_value_dup_text_string(value, &text, &textLen, NULL) != CborNoError) {
        return -1;
    }

    if (findChoice(field->choices, text, output)) {
        free(text);
        return -1;
    }
    free(text);
    return 0;
}
{% if type_conditions["choice"] %}
#endif
{% endif %}
{% endif %}

{% if uint_types.intersection(used_types) %}
{% if type_conditions["uint"] %}
#if {{type_conditions["uint"]}}
{% endif %}
static int validateAndSetUInt(CborValue *value, struct field *field, void *output)
{
    if (!cbor_value_is_unsigned_integer(value)) {
        return -1;
    }
    uint64_t uintVal;
    if (cbor_value_get_uint64(value, &uintVal) != CborNoError) {
        return -1;
    }
    *((uint32_t*)output) = (uint32_t)uintVal;
    return 0;
}
{% if type_conditions["uint"] %}
#endif
{% endif %}
{% endif %}

{% if "gpioPin" in used_types %}
{% if type_conditions["gpioPin"] %}
#if {{type_conditions["gpioPin"]}}
{% endif %}
static int validateAndSetGPIOPin(CborValue *value, struct field *field, void *output)
{
    uint32_t uintVal;
    if (validateAndSetUInt(value, field, &uintVal)) {
        return -1;
    }

    *((uint8_t*)output) = (uint8_t)uintVal;
    return 0;
}
{% if type_conditions["gpioPin"] %}
#endif
{% endif %}
{% endif %}

{% if "gpioLevel" in used_types %}
{% if type_conditions["gpioLevel"] %}
#if {{type_conditions["gpioLevel"]}}
{% endif %}
static int validateAndSetGPIOLevel(CborValue *value, struct field *field, void *output)
{
    uint32_t uintVal;
    if (validateAndSetUInt(value, field, &uintVal)) {
        return -1;
    }

    *((uint8_t*)output) = (uint8_t)uintVal;
    return 0;
}
{% if type_conditions["gpioLevel"] %}
#endif
{% endif %}
{% endif %}

{% if "i2cAddr" in used_types %}
{% if type_conditions["i2cAddr"] %}
#if {{type_conditions["i2cAddr"]}}
{% endif %}
static int validateAndSetI2CAddr(CborValue *value, struct field *field, void *output)
{
    uint32_t uintVal;
    if (validateAndSetUInt(value, field, &uintVal)) {
        return -1;
    }

    *((uint8_t*)output) = (uint8_t)uintVal;
    return 0;
}
{% if type_conditions["i2cAddr"] %}
#endif
{% endif %}
{% endif %}

{% if "int" in used_types %}
{% if type_conditions["int"] %}
#if {{type_conditions["int"]}}
{% endif %}
static int validateAndSetInt(CborValue *value, struct field *field, void *output)
{
    if (!cbor_value_is_integer(value)) {
        return -1;
    }
    int64_t intVal;
    if (cbor_value_get_int64(value, &intVal) != CborNoError) {
        return -1;
    }
    *((int32_t*)output) = (int32_t)intVal;
    return 0;
}
{% if type_conditions["int"] %}
#endif
{% endif %}
{% endif %}

{% if "bool" in used_types %}
{% if type_conditions["bool"] %}
#if {{type_conditions["bool"]}}
{% endif %}
static int validateAndSetBool(CborValue *value, struct field *field, void *output)
{
    if (!cbor_value_is_boolean(value)) {
        return -1;
    }
    
    if (cbor_value_get_boolean(value, output) != CborNoError){
        return -1;
    }
    return 0;
}
{% if type_conditions["bool"] %}
#endif
{% endif %}
{% endif %}

{% if "string" in used_types %}
{% if type_conditions["string"] %}
#if {{type_conditions["string"]}}
{% endif %}
static int validateAndSetString(CborValue *value, struct field *field, void *output)
{
    if (!cbor_value_is_text_string(value)) {
        return -1;
    }
    size_t textLen;
    if (cbor_value_dup_text_string(value, output, &textLen, NULL) != CborNoError) {
        return -1;
    }
    return 0;
}
{% if type_conditions["string"] %}
#endif
{% endif %}
{% endif %}

{% for component in components %}
/**** {{component.name}} ****/
{% if component.condition %}
#if {{ component.condition}}
{% endif %}
    {% for arg in component.arguments %}
    {% if arg.type == "choice" %}
static const struct choice {{arg.enum_name}}Strings[] = {
    {% for choice in arg.options['choices'] %}
    { "{{ choice }}", DeviceProfile_Choices_{{arg.component|title}}_{{arg.name|title}}_{{choice|title}} },
    {% endfor %}
    { NULL, 0 }
};

    {% endif %}
    {% endfor %}
struct field fields_{{component.normalised_name}}[] = {
    {% for arg in component.arguments %}
    {
        .key = "{{arg.name}}",  
        .flags = {% if arg.is_optional %} FIELD_FLAG_OPTIONAL{% else %} FIELD_FLAG_DEFAULT{% endif %}, 
        .dataOffset = offsetof(struct DeviceProfile_{{component.normalised_name}}Config, {{ arg.name }}),
        {% if arg.type == 'choice' %}
        .choices = {{arg.enum_name}}Strings,
        .validateAndSet = validateAndSetChoice
        {% elif arg.type == "gpioPin" %}
        .validateAndSet = validateAndSetGPIOPin
        {% elif arg.type == "gpioLevel" %}
        .validateAndSet = validateAndSetGPIOLevel
        {% elif arg.type == "i2cAddr" %}
        .validateAndSet = validateAndSetI2CAddr
        {% elif arg.type == "uint" %}
        .validateAndSet = validateAndSetUInt
        {% elif arg.type == "int" %}
        .validateAndSet = validateAndSetInt
        {% elif arg.type == "bool" %}
        .validateAndSet = validateAndSetBool
        {% elif arg.type in ("string", "id") %}
        .validateAndSet = validateAndSetString
        {% else %}
        .validateAndSet = NULL
        {% endif %}
    },
    {% endfor %}
};
{% if component.condition %}
#endif
{% endif %}
{% endfor %}

struct component componentDefinitions[] = {
{% for component in components %}
{% if component.condition %}
#if {{ component.condition}}
{% endif %}
    {
        .name = "{{component.name}}",
        .structSize = sizeof(struct DeviceProfile_{{component.normalised_name}}Config),
        .arrayOffset = offsetof(struct DeviceProfile_DeviceConfig, {{component.normalised_field_name}}Config),
        .arrayCountOffset = offsetof(struct DeviceProfile_DeviceConfig, {{component.normalised_field_name}}Count),
        .fields = fields_{{component.normalised_name}},
        .fieldsCount = sizeof(fields_{{component.normalised_name}}) / sizeof(struct field)
    },
{% if component.condition %}
#endif
{% endif %}
{% endfor %}
};

int deserializeComponent(struct component *componentDef, CborValue *map, void *structPtr)
{
    int i;
    for (i = 0; i < componentDef->fieldsCount; i++)
    {
        CborValue value;
        if (cbor_value_map_find_value(map, componentDef->fields[i].key, &value) != CborNoError) {
            return -1;
        }
        if (!cbor_value_is_valid(&value)) {
            if (componentDef->fields[i].flags == FIELD_FLAG_OPTIONAL) {
                continue;
            } else {
                return -1;
            }
        }

        if (componentDef->fields[i].validateAndSet(&value, 
                                                   &componentDef->fields[i], 
                                                   structPtr + componentDef->fields[i].dataOffset)) {
            return -1;
        }
    }
    return 0;
}

int deserializeComponents(struct DeviceProfile_DeviceConfig *config, struct component *componentDef, CborValue *array) {
    CborValue iter;
    size_t len;
    void *structs = NULL, *current;
    int i;

    if (cbor_value_get_array_length(array, &len) != CborNoError) {
        return -1;
    }
    
    structs = calloc(len, componentDef->structSize);
    if (structs == NULL){
        return -1;
    }
    current = structs;
    cbor_value_enter_container(array, &iter);
    for (i = 0; i < len; i ++) {
        if (cbor_value_get_type(&iter) != CborMapType) {
            goto error;
        }

        if (deserializeComponent(componentDef, &iter, current)) {
            goto error;
        }
        cbor_value_advance(&iter);
        current += componentDef->structSize;
    }

    void **arrayEntry = ((void*)config) + componentDef->arrayOffset;
    size_t *arrayCount = ((void*)config) + componentDef->arrayCountOffset;
    *arrayEntry = structs;
    *arrayCount = len;
    return 0;
error:
    free(structs);
    return -1;
}

static int nextUint32(CborValue *it, uint32_t *result)
{
    uint64_t uintValue;
    if (cbor_value_at_end(it)) {
        return  -1;
    }
    if (cbor_value_is_unsigned_integer(it)) {
        if (cbor_value_get_uint64(it, &uintValue) != CborNoError) {
            return -1;
        }
        *result = (uint32_t)uintValue;
        cbor_value_advance(it);
    } else {
        return -1;
    }
    return 0;
}


int deviceProfileDeserialize(const uint8_t *profile, size_t profileLen, struct DeviceProfile_DeviceConfig *config)
{
    CborParser parser;
    CborValue root, array;
    int i;
    uint32_t version;

    memset(config, 0, sizeof(struct DeviceProfile_DeviceConfig));

    if (cbor_parser_init(profile, profileLen, 0, &parser, &root) != CborNoError) {
        ESP_LOGE(TAG, "Failed to init cbor parser");
        return -1;
    }

    if (cbor_value_get_type(&root) != CborArrayType) {
        ESP_LOGE(TAG, "Incorrect root element type, %d expected %d", cbor_value_get_type(&root), CborArrayType);
        return -1;
    }

    cbor_value_enter_container(&root, &array);
    if (nextUint32(&array, &version)) {
        ESP_LOGE(TAG, "Failed to get version");
        return -1;
    }

    if (version != SUPPORTED_VERSION) {
        ESP_LOGE(TAG, "Unsupported version: %d", version);
        return -1;
    }

    ESP_LOGI(TAG, "Profile version %u", version);

    if (cbor_value_get_type(&array) != CborMapType) {
        ESP_LOGE(TAG, "Incorrect element type, %d expected %d", cbor_value_get_type(&array), CborMapType);
        return -1;
    }

    for (i = 0; i < sizeof(componentDefinitions) / sizeof(struct component); i ++) {
        CborValue value;
        CborError err = cbor_value_map_find_value(&array, componentDefinitions[i].name, &value);

        if (err!= CborNoError) {
            ESP_LOGE(TAG, "Find value returned error, %d", err);
            return -1;
        }

        if (cbor_value_get_type(&value) == CborArrayType) {
            deserializeComponents(config, &componentDefinitions[i], &value);
        }
    }
    return 0;
}